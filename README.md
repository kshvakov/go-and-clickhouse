# Go и ClickHouse.

Рассмотрим примеры работы с ClickHouse из Go.

> Для демонстрации будет использоваться вот этот драйвер [Go ClickHouse driver](https://github.com/kshvakov/clickhouse).


Задачи:

* приложение должно уметь собирать одиночные события и отправлять их "пачками"
* в случае ошибки приложение должно попытаться записать события снова
* приложение должно корректно завершать свою работу по сигналу: `SIGINT`, `SIGTERM`

Создадим таблицу для хранения событий

```sql
CREATE TABLE IF NOT EXISTS test_go_worker (
    Time DateTime
    , Value String
) Engine MergeTree PARTITION BY toYYYYMM(Time) ORDER BY (Time)
```

У нас есть структура, которая генерирует события, в реальном приложении это будет клиент для какого-либо брокера сообщений.

```go
type eventGenerator struct {
	ticker  *time.Ticker
	handler func(event)
}
```

При поступлении события клиент вызывает метод `handle` у воркера, метод просто пишет события в буферизованный канал, размер буфера - это количество сообщений которые воркер получил из очереди, но еще не записал.

В воркере есть метод `next`, который выбирает сообщения из `retry` лога или из буферизованного канала, поэтому общий размер сообщений внутри воркера (которые он может потерять при отключении питания) равно размер буферизированного канала + размер retry лога (в данной реализации он равен максимальному размеру записываемого блока).

Пример для запуска.

```sh
go run worker/*.go -h

Usage of /tmp/go-build709694225/b001/exe/main:
  -backlog int
        backlog size (default 1000)
  -clickhouse-dsn string
         (default "tcp://127.0.0.1:9000?debug=false")
  -flush-interval int
        flush interval seconds (default 1)
  -max-block-size int
        max block size (default 500)
```

## Как это работает?

Клиент вызывает метод `handle` у воркера, как только канал полностью заполнен, клиент будет ожидать пока функция `handle` закончит свою работу и не сможет читать сообщения из очереди (kafka, NATS, Rabbit MQ ...).

Раз в N секунд (`flush-interval`). Воркер вызывает метод `flush` (если получен сигнал о завершении, в параметр передается `true`, что сигнализирует о том что нужно записать все события). Воркер выбирает события для записи вызывая метод `next`, либо до достижения `max-block-size` либо по времени (не более `flush-interval`).
Если сообщений больше 0 пишем их в КХ.

Метод `next` читает собщения как из лога, так и из канала, поэтому в методе `flush` мы выставляем log offset в 0, чтоб попытаться вычитать сообщения из лога и если запись проходит успешна чистим этот лог.

```go
// на самом деле есть очень небольшая вероятность того, что несмотря на успешную запись мы вычитали не все сообщения из лога, можно дополнительно это проверять
wrk.retryLog = wrk.retryLog[:0]
```

В случае если произошла ошибка этот лог не чистится и в следующий раз `next` начнет вычитывать события из него.

При получении одного из сигналов: `SIGINT`, `SIGTERM`, воркер вызывает `Unsubscribe` у клиента для предотвращения получения новых сообщений и посылает сигнал на запись всех сообщений находящихся в памяти воркера.

При этом мы выставляем таймаут по истечении которого система в любом случае завершит свою работу

```go
timeout := time.Tick(10 * time.Second)
select {
case <-timeout:
    fmt.Println("shutdown with timeout")
case <-wrk.done:
    fmt.Println("graceful shutdown")
}
```

## Что еще может пойти не так.

Если мы удалим колонку в таблице, то запрос всегда будет возвращать `false` и данные накопленные в памяти в любом случае будут потеряны.